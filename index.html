<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>橫版回合制戰鬥遊戲</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Microsoft JhengHei', Arial, sans-serif;
      background: linear-gradient(to right, #001122, #220011);
      color: white;
      overflow: hidden;
      height: 100vh;
    }
    #game {
      display: flex;
      height: 100vh;
      position: relative;
    }
    #players {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 20px;
      padding: 20px;
      box-sizing: border-box;
    }
    .player {
      width: 250px;
      height: 120px;
      background: rgba(0, 150, 255, 0.3);
      border: 2px solid rgba(0, 255, 0, 0.5);
      border-radius: 15px;
      text-align: center;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
      box-shadow: 0 5px 15px rgba(0,255,0,0.2);
    }
    .player:hover {
      background: rgba(0, 150, 255, 0.5);
      border-color: #00ff00;
    }
    .player.active {
      border-color: yellow;
      box-shadow: 0 0 20px yellow;
      background: rgba(255, 255, 0, 0.3);
    }
    .player.dead {
      opacity: 0.4;
      border-color: gray;
    }
    .name {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      display: block;
    }
    .lv {
      font-size: 12px;
      color: gold;
    }
    .hpbar {
      width: 100%;
      height: 20px;
      background: rgba(0,0,0,0.5);
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
      position: relative;
    }
    .hp {
      height: 100%;
      background: linear-gradient(to right, green, lime);
      transition: width 0.5s;
      position: absolute;
      top: 0;
      left: 0;
    }
    .hptext {
      font-size: 14px;
      color: #00ff00;
    }
    #enemies {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-content: center;
      gap: 10px;
      padding: 20px;
      box-sizing: border-box;
      position: relative;
    }
    .enemy, .boss {
      width: 180px;
      height: 100px;
      background: rgba(255, 50, 50, 0.4);
      border: 2px solid rgba(255, 0, 0, 0.7);
      border-radius: 15px;
      text-align: center;
      padding: 10px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 5px 15px rgba(255,0,0,0.3);
      position: relative;
    }
    .boss {
      width: 280px;
      height: 140px;
      background: rgba(255, 0, 255, 0.5);
      border-color: magenta;
      box-shadow: 0 0 20px magenta;
      font-size: 16px;
    }
    .enemy:hover, .boss:hover {
      background: rgba(255, 50, 50, 0.6);
      border-color: #ff0000;
    }
    .enemy.selected, .boss.selected {
      border-color: yellow;
      box-shadow: 0 0 20px yellow;
    }
    .enemy.dead, .boss.dead {
      opacity: 0.4;
      border-color: gray;
    }
    .ename {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    #prompt {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      padding: 20px 30px;
      border-radius: 20px;
      font-size: 20px;
      border: 2px solid #00ff00;
      box-shadow: 0 0 30px #00ff00;
      z-index: 100;
      white-space: nowrap;
    }
    #log {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 150px;
      background: rgba(0,0,0,0.95);
      overflow-y: auto;
      padding: 10px;
      font-size: 12px;
      line-height: 1.4;
      z-index: 50;
    }
    .log-entry {
      margin-bottom: 5px;
      padding: 2px 5px;
      border-radius: 5px;
    }
    .player-log { color: #00ff00; }
    .enemy-log { color: #ff4444; }
    .heal-log { color: #44ff44; }
    #stats {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      padding: 15px;
      border-radius: 10px;
      font-size: 14px;
    }
    button {
      background: #00ff00;
      color: black;
      border: none;
      padding: 10px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      margin: 5px;
    }
    button:disabled {
      background: gray;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div id="game">
    <div id="players"></div>
    <div id="enemies"></div>
  </div>
  <div id="prompt">按 <span style="color:yellow;">J</span> 普通攻擊 | <span style="color:cyan;">K</span> 技能一 | <span style="color:magenta;">O</span> 技能二 | <span style="color:gold;">P</span> 大招<br>點擊敵人選擇目標</div>
  <div id="log"></div>
  <div id="stats">
    擊敗敵人: <span id="defeated">0</span> | 玩家升級次: <span id="playerUp">0</span> | 敵人升級次: <span id="enemyUp">0</span><br>
    <button onclick="nextWave()">下一波 (測試)</button>
  </div>

  <script>
    // 遊戲核心變數
    let players = [];
    let enemies = [];
    let actionQueue = [];
    let currentActionIndex = 0;
    let activePlayerId = -1;
    let selectedTarget = null;
    let totalDefeated = 0;
    let playerUpgradeCount = 0;
    let enemyUpgradeCount = 0;
    let isPlayerTurn = false;
    let gamePaused = false;
    let bossWave = false;

    // Buff類型定義
    const BUFF_TYPES = {
      ATK_MULT: 'atk_mult',
      DEF_MULT: 'def_mult',
      SPD_MULT: 'spd_mult',
      CRIT_RATE_ADD: 'crit_rate_add',
      CRIT_DMG_MULT: 'crit_dmg_mult',
      HEAL_PER_TURN: 'heal_per_turn',
      INVINCIBLE: 'invincible',
      STUN: 'stun',
      SILENCE: 'silence',
      ATK_REDUCE: 'atk_reduce', // value negative
      DEF_REDUCE: 'def_reduce',
      SPD_REDUCE: 'spd_reduce',
      BURN: 'burn', // {duration, ignore_pct}
      SELF_DMG_BEFORE_ACT: 'self_dmg_before_act', // value = fraction of atk
      TRANSFORM_TIMER: 'transform_timer'
    };

    // Unit 基礎類
    class Unit {
      constructor(name, atk, def, maxHp, spd, isPlayer, id, isBoss = false) {
        this.name = name;
        this.atk = atk;
        this.def = def;
        this.maxHp = maxHp;
        this.hp = maxHp;
        this.spd = spd;
        this.isPlayer = isPlayer;
        this.id = id;
        this.isBoss = isBoss;
        this.skillPoints = 0;
        this.buffs = [];
        this.cooldowns = { k: 0, o: 0, p: 0 };
        this.transformLevel = 0;
        this.preTransformStats = null;
        this.revertTimer = 0;
        this.critRateBase = 0.05;
        this.bossAttackCount = 0; // for boss skill4
        this.alive = true;
      }

      update() {
        // 更新buffs
        this.buffs = this.buffs.filter(buff => {
          if (buff.duration !== undefined) buff.duration--;
          return buff.duration > 0 || buff.duration === undefined; // undefined for permanent
        });

        // 每回合heal
        let heal = 0;
        this.buffs.forEach(b => {
          if (b.type === BUFF_TYPES.HEAL_PER_TURN) heal += b.value;
        });
        if (heal > 0) {
          this.hp = Math.min(this.maxHp, this.hp + heal);
          addLog(`${this.name} 每回合回復 ${heal} HP`, 'heal-log');
        }

        // 冷卻減少
        Object.keys(this.cooldowns).forEach(key => {
          if (this.cooldowns[key] > 0) this.cooldowns[key]--;
        });

        // transform revert
        if (this.revertTimer > 0) {
          this.revertTimer--;
          if (this.revertTimer <= 0 && this.preTransformStats) {
            this.atk = this.preTransformStats.atk;
            this.def = this.preTransformStats.def;
            this.spd = this.preTransformStats.spd;
            this.maxHp = this.preTransformStats.maxHp;
            let ratio = this.hp / this.preTransformStats.oldMaxHp;
            this.hp = ratio * this.maxHp;
            this.preTransformStats = null;
            this.transformLevel = 0;
            addLog(`${this.name} 變身結束，回歸原狀`, 'player-log');
          }
        }

        // check dead
        if (this.hp <= 0) {
          this.alive = false;
        }
      }

      getEffectiveAtk() {
        let mult = 1;
        this.buffs.forEach(b => {
          if (b.type === BUFF_TYPES.ATK_MULT) mult *= (1 + b.value);
          if (b.type === BUFF_TYPES.ATK_REDUCE) mult *= (1 + b.value); // negative
        });
        return this.atk * mult;
      }

      getEffectiveDef() {
        let mult = 1;
        this.buffs.forEach(b => {
          if (b.type === BUFF_TYPES.DEF_MULT) mult *= (1 + b.value);
          if (b.type === BUFF_TYPES.DEF_REDUCE) mult *= (1 + b.value);
        });
        return this.def * mult;
      }

      getEffectiveSpd() {
        let mult = 1;
        this.buffs.forEach(b => {
          if (b.type === BUFF_TYPES.SPD_MULT) mult *= (1 + b.value);
          if (b.type === BUFF_TYPES.SPD_REDUCE) mult *= (1 + b.value);
        });
        return this.spd * mult;
      }

      getEffectiveCritRate() {
        let rate = this.critRateBase;
        this.buffs.forEach(b => {
          if (b.type === BUFF_TYPES.CRIT_RATE_ADD) rate += b.value;
        });
        return Math.min(1, rate);
      }

      getCritDmgMult() {
        let mult = 1;
        this.buffs.forEach(b => {
          if (b.type === BUFF_TYPES.CRIT_DMG_MULT) mult *= b.value;
        });
        return mult;
      }

      isStunned() {
        return this.buffs.some(b => b.type === BUFF_TYPES.STUN);
      }

      isSilenced() {
        return this.buffs.some(b => b.type === BUFF_TYPES.SILENCE);
      }

      isInvincible() {
        return this.buffs.some(b => b.type === BUFF_TYPES.INVINCIBLE);
      }

      takeDamage(dmg, isMagic = false, ignoreDefPct = 0) {
        if (this.isInvincible()) {
          addLog(`${this.name} 無敵！無傷害`, 'heal-log');
          return 0;
        }
        let finalDmg = dmg;
        if (!isMagic) {
          let effDef = this.getEffectiveDef();
          let reducePct = Math.min(1, effDef / 50 * 0.005);
          finalDmg *= (1 - reducePct);
          finalDmg *= (1 - ignoreDefPct);
          // burn ignore
          this.buffs.forEach(b => {
            if (b.type === BUFF_TYPES.BURN) finalDmg *= (1 - b.ignorePct);
          });
        }
        finalDmg = Math.max(1, Math.floor(finalDmg));
        this.hp -= finalDmg;
        if (this.hp <= 0) this.hp = 0;
        if (this.isBoss) this.bossAttackCount++;
        return finalDmg;
      }

      addBuff(buff) {
        // 簡化，替換同類型或疊加
        const existing = this.buffs.find(b => b.type === buff.type);
        if (existing) {
          existing.value = buff.value;
          existing.duration = buff.duration;
        } else {
          this.buffs.push(buff);
        }
      }
    }

    // 玩家角色類，擴展特定技能
    class Player1 extends Unit { // 凌玄夜
      constructor() {
        super('凌玄夜', 300, 650, 1200, 70, true, 0);
      }
      actionJ(target) {
        const segments = [
          {mult: 0.01, magic: false},
          {mult: 0.35, magic: true},
          {mult: 0.55, magic: false},
          {mult: 1.20, magic: true}
        ];
        let currTarget = target;
        segments.forEach(seg => {
          if (currTarget.hp <= 0 || !currTarget.alive) {
            currTarget = getAliveEnemies()[0];
          }
          if (currTarget) {
            let baseDmg = this.getEffectiveAtk() * seg.mult;
            let isCrit = Math.random() < this.getEffectiveCritRate();
            if (isCrit) baseDmg *= (1.5 + Math.random() * 1) * this.getCritDmgMult();
            let actual = currTarget.takeDamage(baseDmg, seg.magic);
            addLog(`${this.name} 普通攻第${seg.mult*100}%段 ${seg.magic?'魔法':'物理'} ${actual}傷害給 ${currTarget.name}`, 'player-log');
          }
        });
        this.skillPoints = Math.min(100, this.skillPoints + 45);
      }
      actionK() {
        if (this.cooldowns.k > 0) return;
        this.addBuff({type: BUFF_TYPES.CRIT_RATE_ADD, value: 0.5, duration: 999}); // 永久
        this.addBuff({type: BUFF_TYPES.HEAL_PER_TURN, value: 200, duration: 999});
        this.addBuff({type: BUFF_TYPES.INVINCIBLE, duration: 1});
        this.cooldowns.k = 2;
        addLog(`${this.name} 虛空！暴擊+50%、每回合回200、無敵1回合`, 'player-log');
      }
      actionO() {
        if (this.cooldowns.o > 0) return;
        let oldRatio = this.hp / this.maxHp;
        let oldMax = this.maxHp;
        this.spd = (this.spd + 60) * 1.8;
        this.maxHp = (this.maxHp + 500) * 1.6;
        this.hp = oldRatio * this.maxHp;
        this.atk *= 2;
        this.cooldowns.o = 3; // 假設CD3
        this.revertTimer = 5;
        if (!this.preTransformStats) {
          this.preTransformStats = {atk: this.atk / 2, def: this.def, spd: this.spd / 1.8 - 60 / 1.8, maxHp: this.maxHp / 1.6 - 500 / 1.6, oldMaxHp: oldMax};
        }
        addLog(`${this.name} 聖者變身！`, 'player-log');
      }
      actionP() {
        if (this.skillPoints < 100 || this.cooldowns.p > 0) return;
        let mult = 0.65 + Math.random() * 0.65;
        let baseDmg = this.getEffectiveAtk() * mult;
        enemies.forEach(e => {
          if (e.alive) {
            let actual = e.takeDamage(baseDmg, true);
            addLog(`${this.name} 大招 ${actual} 給 ${e.name}`, 'player-log');
          }
        });
        this.addBuff({type: BUFF_TYPES.ATK_MULT, value: 0.15, duration: 3});
        this.skillPoints -= 100;
        this.cooldowns.p = 3;
        addLog(`${this.name} 無念無痕！全敵傷害+自身攻+15% 3回合`, 'player-log');
      }
    }

    class Player2 extends Unit { // 吉歐
      constructor() {
        super('吉歐', 230, 900, 1000, 55, true, 1);
      }
      actionJ(target) {
        let baseDmg = this.getEffectiveAtk();
        let isCrit = Math.random() < this.getEffectiveCritRate();
        if (isCrit) baseDmg *= (1.5 + Math.random() * 1) * this.getCritDmgMult();
        let actual = target.takeDamage(baseDmg, false);
        addLog(`${this.name} 普通攻 ${actual} 給 ${target.name}`, 'player-log');
        // 全敵atk -10%
        enemies.forEach(e => {
          if (e.alive) e.addBuff({type: BUFF_TYPES.ATK_REDUCE, value: -0.1, duration: 1});
        });
        addLog('敵方全體攻擊-10% 1回合', 'player-log');
        this.skillPoints = Math.min(100, this.skillPoints + 45);
      }
      actionK(target) {
        if (this.cooldowns.k > 0) return;
        // 全我方def +450% = *5.5
        players.forEach(p => {
          p.addBuff({type: BUFF_TYPES.DEF_MULT, value: 4.5, duration: 2});
        });
        let baseDmg = this.getEffectiveAtk() * 1.3;
        let isCrit = Math.random() < this.getEffectiveCritRate();
        if (isCrit) baseDmg *= (1.5 + Math.random() * 1) * this.getCritDmgMult();
        let actual = target.takeDamage(baseDmg, false);
        target.addBuff({type: BUFF_TYPES.STUN, duration: 1});
        addLog(`${this.name} 寒冰！全我防+450% 2回、${target.name} ${actual}傷害+暈1回`, 'player-log');
        this.cooldowns.k = 3;
      }
      actionO() {
        if (this.cooldowns.o > 0) return;
        this.addBuff({type: BUFF_TYPES.DEF_MULT, value: 1.5, duration: 2});
        let dmg = this.getEffectiveDef();
        let highestHpEnemy = getAliveEnemies().reduce((max, e) => e.hp > max.hp ? e : max);
        let actual = highestHpEnemy.takeDamage(dmg, true);
        addLog(`${this.name} 絕對之劍！防+150% 2回、${highestHpEnemy.name} ${actual}魔法傷害`, 'player-log');
        this.cooldowns.o = 3;
      }
      actionP() {
        if (this.skillPoints < 100 || this.cooldowns.p > 0) return;
        players.forEach(p => {
          p.addBuff({type: BUFF_TYPES.DEF_MULT, value: 0.15, duration: 5});
          p.addBuff({type: BUFF_TYPES.ATK_MULT, value: 0.30, duration: 5});
        });
        enemies.forEach(e => {
          if (e.alive) {
            e.takeDamage(e.maxHp * 0.3, true);
            e.addBuff({type: BUFF_TYPES.STUN, duration: 1});
          }
        });
        let heal1 = this.getEffectiveDef() * 0.1;
        let heal2 = this.getEffectiveAtk() * 0.35;
        let totalHeal = heal1 + heal2;
        players.forEach(p => p.hp = Math.min(p.maxHp, p.hp + totalHeal));
        addLog(`${this.name} 領域！全我防+15%攻+30% 5回、敵全暈1回-30%HP、我方回${Math.floor(totalHeal)}`, 'player-log');
        this.skillPoints -= 100;
        this.cooldowns.p = 5; // 假設
      }
    }

    class Player3 extends Unit { // 千切
      constructor() {
        super('千切', 150, 500, 900, 150, true, 2);
      }
      actionJ(target) {
        let baseDmg = this.getEffectiveAtk();
        let isCrit = Math.random() < this.getEffectiveCritRate();
        if (isCrit) baseDmg *= (1.5 + Math.random() * 1) * this.getCritDmgMult();
        let actual = target.takeDamage(baseDmg, false);
        addLog(`${this.name} 普通攻 ${actual} 給 ${target.name}`, 'player-log');
        // 全我技能值+10, 爆擊傷害*1.2 永久?
        players.forEach(p => p.skillPoints = Math.min(100, p.skillPoints + 10));
        players.forEach(p => p.addBuff({type: BUFF_TYPES.CRIT_DMG_MULT, value: 0.2, duration: 999}));
        addLog('全我技能值+10, 爆擊傷*1.2', 'player-log');
        this.skillPoints = Math.min(100, this.skillPoints + 45);
      }
      actionK(target) {
        if (this.cooldowns.k > 0) return;
        this.addBuff({type: BUFF_TYPES.SPD_MULT, value: 0.2, duration: 1}); // 20% spd
        let baseDmg = this.getEffectiveSpd();
        let actual = target.takeDamage(baseDmg, false, 0.15); // ignore 15% def
        addLog(`${this.name} 神速！spd+20%、${target.name} ${actual} spd傷害(無視15%防)`, 'player-log');
        this.cooldowns.k = 2;
      }
      actionO() {
        if (this.cooldowns.o > 0) return;
        let baseDmg = this.getEffectiveSpd() * 10;
        enemies.forEach(e => {
          let actual = e.takeDamage(baseDmg, false);
          addLog(`${this.name} 領域 ${actual} 給 ${e.name}`, 'player-log');
        });
        enemies.forEach(e => {
          e.addBuff({type: BUFF_TYPES.SELF_DMG_BEFORE_ACT, value: 0.25, duration: 2});
          e.addBuff({type: BUFF_TYPES.DEF_REDUCE, value: -0.3, duration: 2});
        });
        addLog('敵全2回合前自傷25%攻、-30%防', 'player-log');
        this.cooldowns.o = 2;
      }
      actionP() {
        if (this.skillPoints < 100 || this.cooldowns.p > 0) return;
        let sortedEnemies = getAliveEnemies().sort((a,b) => a.getEffectiveSpd() - b.getEffectiveSpd());
        if (sortedEnemies[0]) sortedEnemies[0].addBuff({type: BUFF_TYPES.STUN, duration: 1});
        if (sortedEnemies[1]) sortedEnemies[1].addBuff({type: BUFF_TYPES.STUN, duration: 1});
        this.addBuff({type: BUFF_TYPES.SPD_MULT, value: 1.5, duration: 999}); // 永久?
        this.addBuff({type: BUFF_TYPES.ATK_MULT, value: 0.15, duration: 999});
        // 敵spd < 自 spd , stun 2, def -95%
        let mySpd = this.getEffectiveSpd();
        enemies.forEach(e => {
          if (e.getEffectiveSpd() < mySpd) {
            e.addBuff({type: BUFF_TYPES.STUN, duration: 2});
            e.addBuff({type: BUFF_TYPES.DEF_REDUCE, value: -0.95, duration: 2});
          }
        });
        this.skillPoints -= 100;
        addLog(`${this.name} 速度！最低2敵暈1、低spd敵暈2防-95%、自spd+150%攻+15%`, 'player-log');
        this.cooldowns.p = 3;
      }
    }

    class Player4 extends Unit { // 班尼
      constructor() {
        super('班尼', 100, 430, 800, 43, true, 3);
      }
      actionJ(target) {
        // 全我crit +15%
        players.forEach(p => p.addBuff({type: BUFF_TYPES.CRIT_RATE_ADD, value: 0.15, duration: 1}));
        // 2段隨機連擊
        let seg1 = this.getEffectiveDef() * 1.5; // magic
        let seg2 = this.getEffectiveAtk(); // ignore 10% def
        let actual1 = target.takeDamage(seg1, true);
        let actual2 = target.takeDamage(seg2, false, 0.1);
        addLog(`${this.name} 普通攻 ${actual1}+${actual2} 給 ${target.name} (全我crit+15%)`, 'player-log');
        this.skillPoints = Math.min(100, this.skillPoints + 45);
      }
      actionK(target) {
        if (this.cooldowns.k > 0) return;
        let baseDmg = this.getEffectiveAtk() * 2.5;
        let isCrit = Math.random() < this.getEffectiveCritRate();
        if (isCrit) baseDmg *= (1.5 + Math.random() * 1) * this.getCritDmgMult();
        let actual = target.takeDamage(baseDmg, false);
        target.addBuff({type: BUFF_TYPES.BURN, ignorePct: 0.7, duration: 3});
        addLog(`${this.name} 燃燒之心 ${actual} +燃燒(行動時-900、無視70%防 3回)`, 'player-log');
        this.cooldowns.k = 3; // 假設
      }
      actionO() {
        if (this.cooldowns.o > 0) return;
        // 1. 低70% hp 回80%
        players.forEach(p => {
          if (p.hp < p.maxHp * 0.7) {
            p.hp = p.maxHp * 0.8;
          }
        });
        // 2. 全攻+60% 3回 , 每回合回 10%自hp +300 x3
        let selfHealPerTurn = this.hp * 0.1 + 300;
        players.forEach(p => {
          p.addBuff({type: BUFF_TYPES.ATK_MULT, value: 0.6, duration: 3});
          p.addBuff({type: BUFF_TYPES.HEAL_PER_TURN, value: selfHealPerTurn, duration: 3});
        });
        // 3. 隨機我方立即行動 dmg15%
        let randPlayer = players.filter(p => p.alive)[Math.floor(Math.random() * players.filter(p => p.alive).length)];
        // 立即行動 but dmg 15%, simulate simple atk
        let randTarget = getAliveEnemies()[0];
        if (randPlayer && randTarget) {
          let dmg = randPlayer.getEffectiveAtk() * 0.15;
          randTarget.takeDamage(dmg, false);
          addLog(`${randPlayer.name} 立即行動 ${Math.floor(dmg)} 給 ${randTarget.name} (15%)`, 'player-log');
        }
        addLog(`${this.name} 奇蹟之力！低血回80%、全攻+60%+回血3回、隨機行動`, 'player-log');
        this.cooldowns.o = 4;
      }
      actionP() {
        if (this.skillPoints < 100 || this.cooldowns.p > 0) return;
        // 解除負面buff
        players.forEach(p => {
          p.buffs = p.buffs.filter(b => !isNegativeBuff(b.type));
        });
        // 自 maxhp +18% 3回
        let oldMax = this.maxHp;
        this.maxHp *= 1.18;
        this.hp = (this.hp / oldMax) * this.maxHp;
        this.addBuff({type: BUFF_TYPES.TRANSFORM_TIMER, duration: 3}); // dummy
        // 復活死隊友25%
        players.forEach(p => {
          if (!p.alive && p.hp <= 0) {
            p.hp = p.maxHp * 0.25;
            p.alive = true;
            addLog(`${p.name} 復活25%！`, 'heal-log');
          }
        });
        this.skillPoints -= 100;
        addLog(`${this.name} 奇蹟之心！負buff清除、自上限+18%3回`, 'player-log');
        this.cooldowns.p = 4;
      }
    }

    function isNegativeBuff(type) {
      return [BUFF_TYPES.STUN, BUFF_TYPES.SILENCE, BUFF_TYPES.ATK_REDUCE, BUFF_TYPES.DEF_REDUCE, BUFF_TYPES.SPD_REDUCE, BUFF_TYPES.BURN].includes(type);
    }

    // 敵人類
    class Enemy extends Unit {
      constructor() {
        super('', 0, 0, 0, 0, false, Math.random() * 10000);
      }
      aiAction() {
        if (this.isStunned()) return;
        // self dmg before act
        this.buffs.forEach(b => {
          if (b.type === BUFF_TYPES.SELF_DMG_BEFORE_ACT) {
            let selfDmg = this.getEffectiveAtk() * b.value;
            this.takeDamage(selfDmg, true);
            addLog(`${this.name} 行動前自傷 ${Math.floor(selfDmg)}`, 'enemy-log');
          }
        });
        // 隨機 70% 普通攻, 30% 技能
        if (Math.random() < 0.7) {
          this.normalAttack();
        } else {
          this.randomSkill();
        }
      }
      normalAttack() {
        let targets = players.filter(p => p.alive);
        if (targets.length === 0) return;
        let target = targets[Math.floor(Math.random() * targets.length)];
        let baseDmg = this.getEffectiveAtk() * 1.5; // 最終傷害 *1.5 atk
        let isCrit = Math.random() < this.getEffectiveCritRate();
        if (isCrit) baseDmg *= (1.5 + Math.random() * 1);
        let actual = target.takeDamage(baseDmg, false);
        addLog(`${this.name} 普通攻 ${actual} 給 ${target.name}`, 'enemy-log');
      }
      randomSkill() {
        const skills = [1,2,3,4];
        const skill = skills[Math.floor(Math.random() * skills.length)];
        switch(skill) {
          case 1: this.skillPoJun(); break;
          case 2: this.skillMoJin(); break;
          case 3: this.skillGuWu(); break;
          case 4: this.skillIgnoreDef(); break;
        }
      }
      skillPoJun() {
        let targets = players.filter(p => p.alive);
        let target = targets[Math.floor(Math.random() * targets.length)];
        let baseDmg = this.getEffectiveAtk() * 2.6;
        baseDmg = target.takeDamage(baseDmg, true);
        target.addBuff({type: BUFF_TYPES.SPD_REDUCE, value: -1.5, duration: 2}); // spd *0 ? -150% = /2.5 ?
        target.spd /= 2.5; // simplify
        addLog(`${this.name} 破軍 ${baseDmg}魔法 + spd-150% 2回`, 'enemy-log');
      }
      skillMoJin() {
        let targets = players.filter(p => p.alive);
        let target = targets[Math.floor(Math.random() * targets.length)];
        target.addBuff({type: BUFF_TYPES.SILENCE, duration: 1});
        addLog(`${this.name} 魔禁 ${target.name} 技能禁1回`, 'enemy-log');
      }
      skillGuWu() {
        let self = this;
        let randEnemy = enemies.filter(e => e.alive && e !== this)[Math.floor(Math.random() * (enemies.filter(e => e.alive).length -1))];
        if (randEnemy) {
          randEnemy.addBuff({type: BUFF_TYPES.ATK_MULT, value: 0.5, duration: 1});
          randEnemy.hp = Math.min(randEnemy.maxHp, randEnemy.hp + randEnemy.maxHp * 0.5);
          // immediate action
          setTimeout(() => randEnemy.aiAction(), 500);
          addLog(`${this.name} 鼓舞 ${randEnemy.name} atk+50%回50% +立即行動`, 'enemy-log');
        }
      }
      skillIgnoreDef() {
        players.forEach(p => p.addBuff({type: BUFF_TYPES.CRIT_RATE_ADD, value: 0.1, duration: 1}));
        // attacks ignore 20% def ? for next enemy atk
        enemies.forEach(e => e.addBuff({type: 'ignore_def_next', value: 0.2, duration: 1}));
        addLog('敵方我crit+10%、下攻無視我20%防', 'enemy-log');
      }
    }

    class Boss extends Unit {
      constructor(baseEnemy) {
        let mult = 2 + Math.random() * 0.99;
        super('BOSS', baseEnemy.atk * mult, baseEnemy.def * mult, baseEnemy.maxHp * mult, baseEnemy.spd * mult, false, 9999, true);
        this.baseMult = mult;
        this.healTurn = 0;
      }
      update() {
        super.update();
        this.healTurn++;
        if (this.healTurn % 2 === 0) {
          let heal = this.hp * 0.45;
          this.hp = Math.min(this.maxHp, this.hp + heal);
          addLog(`${this.name} 每2回合回45% HP`, 'enemy-log');
        }
        // 狂暴 <40%
        if (this.hp / this.maxHp < 0.4) {
          this.addBuff({type: BUFF_TYPES.ATK_MULT, value: 1.5, duration: 999});
          this.addBuff({type: BUFF_TYPES.DEF_MULT, value: 1.5, duration: 999});
          this.addBuff({type: BUFF_TYPES.SPD_MULT, value: 1.5, duration: 999});
          // add extra magic
          this.addBuff({type: BUFF_TYPES.ATK_MULT, value: 1, duration: 999}); // extra atk as magic
        }
        // passive when player die
        // handled globally
      }
      aiAction() {
        if (this.isStunned()) return;
        // self dmg
        this.buffs.forEach(b => {
          if (b.type === BUFF_TYPES.SELF_DMG_BEFORE_ACT) {
            let selfDmg = this.getEffectiveAtk() * b.value;
            this.takeDamage(selfDmg, true);
          }
        });
        // boss skills random or intelligent
        const skills = [1,2,3,4];
        const skill = skills[Math.floor(Math.random() * skills.length)];
        switch(skill) {
          case 1: this.bossMieShi(); break;
          case 2: this.bossTianHeng(); break;
          case 3: this.bossGuiJia(); break;
          case 4: this.bossLianJi(); break; // immediate after dmg
        }
      }
      bossMieShi() {
        let totalDmg = this.hp * 1.2; // 120% current hp
        let alivePlayers = players.filter(p => p.alive);
        let perPlayer = totalDmg / alivePlayers.length;
        let randTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
        randTarget.addBuff({type: BUFF_TYPES.STUN, duration: 1});
        alivePlayers.forEach(p => p.takeDamage(perPlayer, false));
        addLog(`${this.name} 滅世！分散${Math.floor(totalDmg)}傷害 +隨機暈1`, 'enemy-log');
      }
      bossTianHeng() {
        let minion = new Enemy();
        let mult = 0.7;
        minion.atk = this.atk * mult;
        minion.def = this.def * mult;
        minion.maxHp = this.maxHp * 0.7;
        minion.hp = minion.maxHp;
        minion.spd = this.spd * mult;
        minion.name = 'BOSS隨從';
        enemies.push(minion);
        renderEnemies();
        addLog(`${this.name} 天珩！召喚隨從`, 'enemy-log');
      }
      bossGuiJia() {
        this.addBuff({type: 'damage_reduce', value: 3, duration: 1}); // next dmg /3
        addLog(`${this.name} 龜甲！下次傷害減300% CD4`, 'enemy-log');
      }
      bossLianJi() {
        // handled on take dmg
      }
      takeDamage(dmg, isMagic, ignoreDefPct) {
        let reduceBuff = this.buffs.find(b => b.type === 'damage_reduce');
        if (reduceBuff) {
          dmg /= reduceBuff.value;
          // remove buff
          this.buffs = this.buffs.filter(b => b !== reduceBuff);
        }
        let actual = super.takeDamage(dmg, isMagic, ignoreDefPct);
        // skill4: 2次攻擊後立即2次行動
        if (this.bossAttackCount >= 2) {
          setTimeout(() => {
            this.aiAction();
            setTimeout(() => this.aiAction(), 1000);
          }, 500);
          this.bossAttackCount = 0;
          addLog(`${this.name} 反擊2次！`, 'enemy-log');
        }
        return actual;
      }
    }

    // 初始化玩家
    function initPlayers() {
      players = [
        new Player1(),
        new Player2(),
        new Player3(),
        new Player4()
      ];
      renderPlayers();
    }

    // 生成敵人
    function generateEnemies() {
      let num = 3 + Math.floor(Math.random() * 3); // 3-5
      let mult = 1;
      if (enemyUpgradeCount > 0) {
        // already multiplied
        mult = 1;
      }
      for (let i = 0; i < num; i++) {
        let e = new Enemy();
        e.name = `敵人${i+1}`;
        e.atk = 300 + Math.floor(Math.random() * 51);
        e.def = 300 + Math.floor(Math.random() * 601);
        e.maxHp = 500 + Math.floor(Math.random() * 301);
        e.hp = e.maxHp;
        e.spd = 20 + Math.floor(Math.random() * 81);
        // apply upgrade mult
        let upgradeMult = Math.pow(1.5 + Math.random() * 1.1, enemyUpgradeCount);
        e.atk *= upgradeMult;
        e.def *= upgradeMult;
        e.maxHp *= upgradeMult;
        e.hp = e.maxHp;
        e.spd *= upgradeMult;
        enemies.push(e);
      }
      // BOSS wave every 15 defeated
      if (totalDefeated % 15 === 0 && totalDefeated > 0) {
        let baseE = enemies[0]; // use first as base
        let boss = new Boss(baseE);
        boss.name = `BOSS-${Math.floor(totalDefeated / 15) + 1}`;
        enemies = [boss]; // replace or add?
        enemies.push(...Array.from({length: 2}, () => {
          let minion = new Enemy();
          minion.atk = boss.atk * 0.7;
          // etc
          minion.name = 'BOSS小兵';
          minion.maxHp *= 0.7;
          minion.hp = minion.maxHp;
          return minion;
        }));
        bossWave = true;
      }
      renderEnemies();
    }

    // 升級
    function upgradePlayers() {
      let mult = 1.1 + Math.random() * 0.4;
      players.forEach(p => {
        if (p.alive) {
          p.atk *= mult;
          p.def *= mult;
          p.maxHp *= mult;
          p.hp = p.maxHp;
          p.spd *= mult;
          p.lv ++;
        }
      });
      playerUpgradeCount ++;
      addLog(`玩家升級！屬性x${mult.toFixed(2)} LV+1`, 'heal-log');
    }

    function upgradeEnemies() {
      enemyUpgradeCount ++;
      addLog(`敵人強化！下波x${(1.5 + Math.random()*1.1).toFixed(2)}`, 'enemy-log');
    }

    // 渲染
    function renderPlayers() {
      const container = document.getElementById('players');
      container.innerHTML = '';
      players.forEach((p, i) => {
        const div = document.createElement('div');
        div.className = `player ${p.alive ? '' : 'dead'}`;
        div.dataset.id = i;
        div.innerHTML = `
          <span class="name">${p.name}</span>
          <span class="lv">LV.${p.lv || 1}</span>
          <div class="hpbar"><div class="hp" style="width: ${ (p.hp / p.maxHp * 100) || 0 }%"></div></div>
          <span class="hptext">${p.hp}/${p.maxHp}</span>
        `;
        div.onclick = () => {}; // no need
        container.appendChild(div);
      });
    }

    function renderEnemies() {
      const container = document.getElementById('enemies');
      container.innerHTML = '';
      enemies.forEach((e, i) => {
        const div = document.createElement('div');
        div.className = `enemy ${e.isBoss ? 'boss' : ''} ${e.alive ? '' : 'dead'} ${selectedTarget === e ? 'selected' : ''}`;
        div.dataset.id = i;
        div.innerHTML = `
          <span class="ename">${e.name}</span>
          <div class="hpbar"><div class="hp" style="width: ${ (e.hp / e.maxHp * 100) || 0 }%"></div></div>
          <span style="font-size:12px;">${e.hp}/${e.maxHp}</span>
        `;
        div.onclick = () => selectTarget(e);
        container.appendChild(div);
      });
      updateStats();
    }

    function selectTarget(target) {
      selectedTarget = target;
      renderEnemies();
    }

    function getAlivePlayers() {
      return players.filter(p => p.alive);
    }

    function getAliveEnemies() {
      return enemies.filter(e => e.alive);
    }

    function addLog(msg, className = '') {
      const log = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = `log-entry ${className}`;
      entry.textContent = msg;
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
    }

    function updateStats() {
      document.getElementById('defeated').textContent = totalDefeated;
      document.getElementById('playerUp').textContent = playerUpgradeCount;
      document.getElementById('enemyUp').textContent = enemyUpgradeCount;
    }

    // 鍵盤輸入
    document.addEventListener('keydown', (e) => {
      if (!isPlayerTurn || gamePaused) return;
      let player = players[activePlayerId];
      if (!player || !player.alive || player.isStunned()) return;
      switch(e.key.toUpperCase()) {
        case 'J':
          if (selectedTarget && selectedTarget.alive) {
            player.actionJ(selectedTarget);
            player.skillPoints = Math.min(100, player.skillPoints + 45);
            nextAction();
          }
          break;
        case 'K':
          if (!player.isSilenced() && player.cooldowns.k === 0 && selectedTarget && selectedTarget.alive) {
            player.actionK(selectedTarget);
            nextAction();
          }
          break;
        case 'O':
          if (!player.isSilenced() && player.cooldowns.o === 0) {
            player.actionO();
            nextAction();
          }
          break;
        case 'P':
          if (player.skillPoints >= 100 && !player.isSilenced() && player.cooldowns.p === 0) {
            player.actionP();
            nextAction();
          }
          break;
      }
      renderPlayers();
      renderEnemies();
    });

    // burn dmg when player act
    function applyBurnOnPlayerAct() {
      enemies.forEach(e => {
        e.buffs.forEach(b => {
          if (b.type === BUFF_TYPES.BURN) {
            let burnDmg = 900;
            e.takeDamage(burnDmg, true);
            addLog(`${e.name} 燃燒 -900`, 'player-log');
          }
        });
      });
    }

    // 下一行動
    function nextAction() {
      applyBurnOnPlayerAct();
      selectedTarget = null;
      renderEnemies();
      if (currentActionIndex >= actionQueue.length) {
        endTurn();
        return;
      }
      let unit = actionQueue[currentActionIndex];
      currentActionIndex++;
      if (!unit.alive) {
        nextAction();
        return;
      }
      if (unit.isPlayer) {
        // player turn
        isPlayerTurn = true;
        activePlayerId = players.indexOf(unit);
        document.querySelectorAll('.player')[activePlayerId].classList.add('active');
        addLog(`輪到 ${unit.name} 行動！選擇目標並按鍵`);
      } else {
        // enemy turn
        isPlayerTurn = false;
        document.querySelectorAll('.player').forEach(d => d.classList.remove('active'));
        setTimeout(() => {
          unit.aiAction();
          renderPlayers();
          renderEnemies();
          nextAction();
        }, 1000);
      }
    }

    function endTurn() {
      // update all
      [...players, ...enemies].forEach(u => u.update());
      // check deaths
      enemies = enemies.filter(e => {
        if (!e.alive && e.hp <= 0) {
          totalDefeated++;
          if (totalDefeated % 3 === 0) upgradePlayers();
          if (totalDefeated % 5 === 0) upgradeEnemies();
          // boss passive
          let boss = enemies.find(b => b.isBoss);
          if (boss) {
            boss.hp = Math.min(boss.maxHp, boss.hp + boss.maxHp * 0.05);
            boss.atk *= 1.2;
            boss.def *= 1.6;
            boss.spd *= 0.8;
          }
          return false;
        }
        return true;
      });
      players = players.filter(p => {
        if (!p.alive) return false;
        return true;
      });
      renderPlayers();
      renderEnemies();
      // check win/lose
      if (getAlivePlayers().length === 0) {
        addLog('玩家全滅！遊戲結束', 'enemy-log');
        gamePaused = true;
        return;
      }
      if (getAliveEnemies().length === 0) {
        addLog('敵全滅！生成下一波', 'player-log');
        setTimeout(generateEnemies, 2000);
        return;
      }
      // next turn
      setTimeout(startTurn, 1500);
    }

    function startTurn() {
      actionQueue = [...getAlivePlayers(), ...getAliveEnemies()].sort((a,b) => b.getEffectiveSpd() - a.getEffectiveSpd());
      currentActionIndex = 0;
      nextAction();
    }

    // 測試下一波
    window.nextWave = function() {
      enemies = [];
      renderEnemies();
      generateEnemies();
    };

    // 初始化遊戲
    initPlayers();
    generateEnemies();
    startTurn();

    // 全局click clear select
    document.getElementById('game').onclick = (e) => {
      if (e.target.classList.contains('enemy') || e.target.classList.contains('boss')) return;
      selectedTarget = null;
      renderEnemies();
    };
  </script>
</body>
</html>

